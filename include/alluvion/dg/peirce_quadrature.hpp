#ifndef ALLUVION_DG_PEIRCE_QUADRATURE_HPP
#define ALLUVION_DG_PEIRCE_QUADRATURE_HPP

#include <Eigen/Dense>

#include "alluvion/dg/common.hpp"

namespace alluvion {
namespace dg {
template <typename TF, U M>
struct PeirceConst {
  constexpr PeirceConst() : cosphi(), sinphi(), r(), b(), c() {
    if constexpr (M == 7) {
      cosphi[0] = -0.989400934991649932596154173450;
      cosphi[1] = -0.944575023073232576077988415535;
      cosphi[2] = -0.865631202387831743880467897712;
      cosphi[3] = -0.755404408355003033895101194847;
      cosphi[4] = -0.617876244402643748446671764049;
      cosphi[5] = -0.458016777657227386342419442984;
      cosphi[6] = -0.281603550779258913230460501460;
      cosphi[7] = -0.0950125098376374401853193354250;
      cosphi[8] = 0.0950125098376374401853193354250;
      cosphi[9] = 0.281603550779258913230460501460;
      cosphi[10] = 0.458016777657227386342419442984;
      cosphi[11] = 0.617876244402643748446671764049;
      cosphi[12] = 0.755404408355003033895101194847;
      cosphi[13] = 0.865631202387831743880467897712;
      cosphi[14] = 0.944575023073232576077988415535;
      cosphi[15] = 0.989400934991649932596154173450;

      sinphi[0] = 0.145209468829167280282880949784;
      sinphi[1] = 0.328295637781256768450207178290;
      sinphi[2] = 0.500682156115630586381637460127;
      sinphi[3] = 0.655258864753333819831390558218;
      sinphi[4] = 0.786275363090364449654701638116;
      sinphi[5] = 0.888943547917689727168085390228;
      sinphi[6] = 0.959530843792169792240614445637;
      sinphi[7] = 0.995476078554554141853594593613;
      sinphi[8] = 0.995476078554554141853594593613;
      sinphi[9] = 0.959530843792169792240614445637;
      sinphi[10] = 0.888943547917689727168085390228;
      sinphi[11] = 0.786275363090364449654701638116;
      sinphi[12] = 0.655258864753333819831390558218;
      sinphi[13] = 0.500682156115630586381637460127;
      sinphi[14] = 0.328295637781256768450207178290;
      sinphi[15] = 0.145209468829167280282880949784;

      r[0] = 0.178484181495847855850677493654;
      r[1] = 0.351231763453876315297185517095;
      r[2] = 0.512690537086476967886246568630;
      r[3] = 0.657671159216690765850302216643;
      r[4] = 0.781514003896801406925230055520;
      r[5] = 0.880239153726985902122955694488;
      r[6] = 0.950675521768767761222716957896;
      r[7] = 0.990575475314417335675434019941;

      b[0] = 0.0271524594117540948517805724560;
      b[1] = 0.0622535239386478928628438369944;
      b[2] = 0.0951585116824927848099251076022;
      b[3] = 0.124628971255533872052476282192;
      b[4] = 0.149595988816576732081501730547;
      b[5] = 0.169156519395002538189312079030;
      b[6] = 0.182603415044923588866763667969;
      b[7] = 0.189450610455068496285396723208;
      b[8] = 0.189450610455068496285396723208;
      b[9] = 0.182603415044923588866763667969;
      b[10] = 0.169156519395002538189312079030;
      b[11] = 0.149595988816576732081501730547;
      b[12] = 0.124628971255533872052476282192;
      b[13] = 0.0951585116824927848099251076022;
      b[14] = 0.0622535239386478928628438369944;
      b[15] = 0.0271524594117540948517805724560;

      c[0] = 0.00562468801729387510978164823574;
      c[1] = 0.0207256163361080832976198832636;
      c[2] = 0.0404911727416291986723229686404;
      c[3] = 0.0584507163831210890389534044078;
      c[4] = 0.0683346415192924710976504217793;
      c[5] = 0.0658877907331894786007565847476;
      c[6] = 0.0501234323946693489415882264535;
      c[7] = 0.0236952752080297885746601958053;
    }
  }

  TF cosphi[2 * M + 2];
  TF sinphi[2 * M + 2];
  TF r[M + 1];
  TF b[2 * M + 2];
  TF c[M + 1];
};
template <typename TF, U M>
class PeirceQuadrature {
 public:
  using Integrand = std::function<TF(Vector3r<TF> const&)>;

  static TF integrate(Integrand integrand, TF int_radius) {
    auto res = 0.0;
    auto xi = Vector3r<TF>{};
    constexpr PeirceConst<TF, M> kPeirceConst;
    constexpr U kNumPhi = 2 * M + 2;
    constexpr U kNumTheta = 4 * M + 4;
    constexpr U kNumR = M + 1;
    constexpr TF kPi = static_cast<TF>(
        3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651e+00L);

    for (U i = 0; i < kNumTheta; ++i) {
      TF theta = 2 * kPi * (i + 1) / kNumTheta;
      TF sin_theta = sin(theta);
      TF cos_theta = cos(theta);
      for (U j = 0; j < kNumPhi; ++j) {
        xi(0) = kPeirceConst.sinphi[j] * cos_theta;
        xi(1) = kPeirceConst.sinphi[j] * sin_theta;
        xi(2) = kPeirceConst.cosphi[j];
        for (U k = 0; k < kNumR; ++k) {
          TF wijk = 2 * kPi * kPeirceConst.b[j] * kPeirceConst.c[k] / kNumTheta;
          res += wijk * integrand(int_radius * kPeirceConst.r[k] * xi);
        }
      }
    }
    return res * int_radius * int_radius * int_radius;
  }
};
}  // namespace dg
}  // namespace alluvion

#endif
